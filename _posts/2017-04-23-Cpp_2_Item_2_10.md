---
layout: post
title: 读书笔记二 Item 2-10
description: Effective C++,由侯捷译。
categories:
    - Cpp
comments: true
permalink: 
---
Effective C++ 读书笔记二：Item 2-10

## item 2 尽量以const, enum, inline替换 #define

###  一 常量替换 #define

*  常量指针(const pointer)。常量定义式通常放在头文件中。若要在头文件中定义一个常量的 char\*-based 字符串。const必须写两次

    ```C++
              const char * const authorName = "Scott Meyers";
    ```

*  class专属常量。
    *  类静态成员。
        *  使用关键字static。 
        *  特点：当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
        *  不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。
        *  静态成员函数即使在类对象不存在的情况下也能被调用
        *  静态函数只要使用类名加范围解析运算符 :: 就可以访问
        *  静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数
        *  静态成员函数有一个类范围，他们不能访问类的 this 指针。
    *  特例

    ```C++
              class GamePlayer{
              private:
                  static const int NumTurns = 5;
                  int scores[NUmTurns];
              };
              // 此处NumTurns是声明式而非定义式。但如果他是个class专属常量又是static且为整数类型(ints, chars, bools)，则须特殊处理。即所谓的in class初值设定。
    ```

*  in class初值设定方法二： the enum hack
    *  理论基础：一个属于枚举类型的数值可以当ints被使用。
    *  enum hack值的认识：
        *  enum hack的行为某方面比较像#define而不像const。例如取一个const的地址是合法的，但取一个enum的地址是不合法的，而取一个#define的地址通常也是不合法的。
        *  如果不想让别人获得一个pointer或reference指向你的某个整数常量。enum可以帮助你实现这个约束。
    ```C++
              #define CALL_WITH_MAX(a,b) f((a)>(b)?(a):(b))
              int a = 5;
              int b = 0;
              CALL_WITH_MAX(++a,b); // a被累加两次。 ++a=6,b=0. a>b, 返回++a=7
              CALL_WITH_MAX(++a,b+10) // a被累加一次. 
              //
              template<typename T>
              inline void callWithMax(const T& a, const T&b){
                  f(a>b ? a : b);  
              }
    ```
*  请记住
    *  `对于常纯常量，最好以const对象或enums替换#defines`。
    *  `对于形似函数的宏(macros)，最好改用inline函数替换#defines`。

## item 2 尽可能使用const

* const 修饰指针
    *  关键字const出现在星号左边，表示被指物是常量
    *  关键字const出现在星号右边，表示指针自身是常量
    *  关键字const出现在星号两遍，表示被指物和指针两者都是常量。

    ```C++
              void f1(const Widget * pw);
              void f2(Widget const * pw);
              // f1和f2都指向一个不变的Widget对象
    ```

*  const - STL迭代器
    
        ```C++
              std::vector<int> vec;

              const std::vector<int>::iterator iter = vec.begin();
              *iter = 10;   // 没问题
              ++iter;       // 有问题
              std::vector<int>::const_iterator cIter = vec.begin();
              *cIter = 10;
              ++cIter;
        ```

*  const - 令函数返回一个常量值
    *  可以降低因程序员错误而造成的意外，而又不至于放弃安全性和高效性。

        ```C++
              class Rational {...};
              const Rational operator* (const Rational& lhs, const Rational & rhs);

              Rational a,b,c;
              (a*b)=c  //在a*b的成果上调用operator= 
        ```

*  const参数，就像local const对象一样。除非需要改动参数或local对象，否则将const参数声明为const。

*  const成员函数, part 1
    *  const成员函数能够作用于const对象。
    *  const成员函数的重要性：
        *  class接口比较容易理解。得知哪个函数可以改动对象内容。
        *  使操作const对象成为可能。是pass by reference-to-const方式传递对象技术可行
    *  一件实事：两个成员函数如果只是常量性(constness)不同，可以被重载。

        ```C++
              class TextBook{
                public:
                  const char& operator[](std::size_t position) const
                  {return text[position];}

                  char& operator[] (std::size_t position)
                  {return text[position];}
                private:
                  std::string text;
              };

              TextBlock tb("Hello");
              cout << tb[0]; //调用non-const TextBlock
              tb[0] = 'x';  // 返回类型为reference to char 不是char。 如果operator[]只返回一个char。则改句子不能编译通过。因为如果函数返回类型是个内置类型，那么改动函数返回值从来就不合法

              const TextBlock cbt("Hello");
              cout << cbt[0];
              cbt[0] = 'x'; 不合法
              // const对象大多用于passed by pointer-to-const或passed by reference-to-pointer传递结果.
              例如：
              void print(const TextBlock & ctb){
                cout << ctb[0];
                ...
              }
        ```

*  const成员函数, part 2 哲学思想
    *  bitwise constness (又称physical constness)
        *  成员函数只有在不更改对象的任何成员变量(static 除外)时才可以说是const。也就是说他不更改对象内任何一个bit。
        *  bitwise constness是C++对常量性(constness)的定义
        *  bitwise测试：编译器寻找成员变量的赋值动作。
        *  问题：创建一个常量对象并设以某值，而且只对他调用const成员函数，还是可以改变它的值。同时也能通过编译器的bitwise测试。

        ```C++
              class CTextBlock{
                public:
                  const char& operator[](std::size_t position) const
                  {return pText[position];}
                private:
                  std::string pText;
              };

              const CTextBlock cctb("Hello");
              char * pc = & cctb[0];
              \*pc = 'J';                    //cctb的值为'Jello'
        ```

    *  logical constness
        *  const成员函数可以修改对象内的某些bits，但是只有在程序员侦测不出的情况下。

        ```C++
              class CTextBlock{
                public:
                    std::size_t length() const;
                private:
                  std::string pText;
                  std::size_t textLength;
                  bool lengthIsValid;
              };

              std::size_t CTextBlock::length() const {      // `错误：在const成员函数内不能赋值`
                  if(!lengthIsValid){                       // `textLength和lengthIsValid`
                      textLength = std::strlen(pText);  
                      lengthIsValid = true;
                  }
                  return textLength;
              }
        ```

        *  mutable(可变的)释放掉non-static成员变量bitwise constness约束。

*  const成员函数, part 3 在const和non-const成员函数中避免重复。
      *  在const和non-const成员函数中有很多代码重复。
      *  使用转型(casting)。用non-const成员函数调用const成员函数。反过来则不行，即const成员函数调用non-const成员函数。因为对象有可能因此被修改

        ```C++
              class TextBlock{
                  public:
                      const char& operator[](std::size_t position) const{
                        ...
                        ...
                        ...
                        return text[position];
                      }
                      char& operator[](std::size_t position){
                          return const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);
                          // 为*this加上const，调用const operation[],最后将operation[]返回值的const移除。
                      }
              };
        ```      
