---
layout: post
title: 读书笔记二 Item 2-10
description: Effective C++,由侯捷译。
categories:
    - Cpp
comments: true
permalink: 
---
Effective C++ 读书笔记二：Item 2-10

## item 2 尽量以const, enum, inline替换 #define

###  一 常量替换 #define

*  常量指针(const pointer)。常量定义式通常放在头文件中。若要在头文件中定义一个常量的 char\*-based 字符串。const必须写两次

    ```C++
              const char * const authorName = "Scott Meyers";
    ```

*  class专属常量。
    *  类静态成员。
        *  使用关键字static。 
        *  特点：当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
        *  不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。
        *  静态成员函数即使在类对象不存在的情况下也能被调用
        *  静态函数只要使用类名加范围解析运算符 :: 就可以访问
        *  静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数
        *  静态成员函数有一个类范围，他们不能访问类的 this 指针。
    *  特例

    ```C++
              class GamePlayer{
              private:
                  static const int NumTurns = 5;
                  int scores[NUmTurns];
              };
              // 此处NumTurns是声明式而非定义式。但如果他是个class专属常量又是static且为整数类型(ints, chars, bools)，则须特殊处理。即所谓的in class初值设定。
    ```

*  in class初值设定方法二： the enum hack
    *  理论基础：一个属于枚举类型的数值可以当ints被使用。
    *  enum hack值的认识：
        *  enum hack的行为某方面比较像#define而不像const。例如取一个const的地址是合法的，但取一个enum的地址是不合法的，而取一个#define的地址通常也是不合法的。
        *  如果不想让别人获得一个pointer或reference指向你的某个整数常量。enum可以帮助你实现这个约束。
    ```C++
              #define CALL_WITH_MAX(a,b) f((a)>(b)?(a):(b))
              int a = 5;
              int b = 0;
              CALL_WITH_MAX(++a,b); // a被累加两次。 ++a=6,b=0. a>b, 返回++a=7
              CALL_WITH_MAX(++a,b+10) // a被累加一次. 
              //
              template<typename T>
              inline void callWithMax(const T& a, const T&b){
                  f(a>b ? a : b);  
              }
    ```
*  请记住
    *  `对于常纯常量，最好以const对象或enums替换#defines`。
    *  `对于形似函数的宏(macros)，最好改用inline函数替换#defines`。

## item 2 尽可能使用const

* const 修饰指针
    *  关键字const出现在星号左边，表示被指物是常量
    *  关键字const出现在星号右边，表示指针自身是常量
    *  关键字const出现在星号两遍，表示被指物和指针两者都是常量。

    ```C++
              void f1(const Widget * pw);
              void f2(Widget const * pw);
              // f1和f2都指向一个不变的Widget对象
    ```

*  const - STL迭代器
    
        ```C++
              std::vector<int> vec;

              const std::vector<int>::iterator iter = vec.begin();
              *iter = 10;   // 没问题
              ++iter;       // 有问题
              std::vector<int>::const_iterator cIter = vec.begin();
              *cIter = 10;
              ++cIter;
        ```

*  const - 令函数返回一个常量值
    *  可以降低因程序员错误而造成的意外，而又不至于放弃安全性和高效性。

        ```C++
              class Rational {...};
              const Rational operator* (const Rational& lhs, const Rational & rhs);

              Rational a,b,c;
              (a*b)=c  //在a*b的成果上调用operator= 
        ```

*  const参数，就像local const对象一样。除非需要改动参数或local对象，否则将const参数声明为const。

*  const成员


